/**
 * File:
 *   toposort.ycp
 *
 * Module:
 *   System Services (Runlevel) (formerly known as Runlevel Editor)
 *
 * Summary:
 *   Topological sorting for script dependencies
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 */

{
    import "Map";
    import "String";

    /**
     * Topologically sort a directed acyclic graph, ie. linearize a
     * partial ordering.
     * (what if the graph is a multigraph??)
     * @param dag A DAG as a map:
     *  nodes are keys, values are lists of nodes that are reached
     *  by an edge from the respective key.
     * @return [out, rest]<br>
     *  out: a list containing the keys of the map in topological order<br>
     *  rest: a list, empty if the graph was acyclic, otherwise it is
     *   a superset of the nodes forming the cycle
     *   and "out" is a partial result
     */
    define list< list<string> > TopologicalSort (map<string, list<string> > dag) {
        list<string> out = [];
        map<string, integer> in_degree =
            (map<string, integer>) mapmap (string vertex, list<string> targets,
                                           dag,
                                           ``($[vertex: 0]));
        foreach (string vertex, list<string> targets, dag, ``{
            foreach (string target, targets, ``{
                in_degree[target] = in_degree[target]:0 + 1;
            });
        });

        while (size (in_degree) > 0)
        {
            // get the vertices that can go next because they have zero in degree
            map<string, integer> next_m =
                (map<string, integer>) filter (string vertex, integer d,
                                               in_degree,
                                               ``(d == 0));
            if (size (next_m) == 0)
            {
                // the graph is cyclic!
                break;
            }
            foreach (string vertex, integer dummy, next_m, ``{
                out = add(out, vertex);
            });
            // remove the vertices
            in_degree = (map<string, integer>) filter (string vertex, integer d,
                                                       in_degree,
                                                       ``(d != 0));
            // remove the edges that were leading from them
            foreach (string vertex, integer dummy, next_m, ``{
                foreach (string target, dag[vertex]:[], ``{
                    in_degree[target] = in_degree[target]:0 - 1;
                });
            });
        }

        list<string> rest = (list<string>) maplist (string k, integer v, in_degree, ``( k )); //mapkeys
        if (size (rest) > 0)
        {
            y2error ("Cyclic subgraph found, remainder has %1 nodes: %2",
                     size (rest), rest);
        }
        return [out, rest];
    }

    /**
     * TopologicalSort as implemented above only works on graphs
     * with string vertices.
     * Now we will
     * 1. generalize it to arbitrary data ("things")
     * 2. exploit the order of keys in map<string, ...> to produce a *stable*
     *    topological sort (one that preserves the order of unrelated vertices)
     */
    typedef any thing_t;
    typedef string vertex_t;

    /**
     * @param things a list of things
     * @param edge   a function determining whether
     *               a directed edge exists between two things
     * @return [out, rest]<br>
     *  out: a list of things in topological order
     *       (starting with things that have no *incoming* edge)<br>
     *  rest: a list, empty if the graph was acyclic, otherwise it is
     *   a superset of the things forming the cycle
     *   and "out" is a partial result
     *
     */
    list<list<thing_t> > StableTopologicalSort(list<thing_t> things,
                                               boolean(thing_t, thing_t) edge) {
      // The stability of the sort is achieved
      // by using zero-padded numeric strings as graph vertices.
      // For example, for 31337 things we will need 5-character vertices.
      integer num_things = size(things);
      integer vertex_size = size(tostring(num_things));

      integer i = 0;
      map<vertex_t, thing_t> by_vertex = listmap(thing_t th, things, {
          i = i + 1;
          string vertex = String::PadZeros(tostring(i), vertex_size);
          return $[vertex : th];
      });
      list<vertex_t> vertices = (list<vertex_t>) Map::Keys(by_vertex);

      map<vertex_t, list<vertex_t> > vertex_graph = mapmap(vertex_t v, thing_t th,
                                                           by_vertex, {
          list<vertex_t> targets = filter(vertex_t target, vertices,
                                          ``( edge(th, by_vertex[target]:nil) ));
          return $[v : targets];
      });

      list<list<vertex_t> > ordered_vertices = TopologicalSort(vertex_graph);

      list<list<thing_t> > ordered_things = maplist(list<vertex_t> vertices,
                                                    ordered_vertices, {
          return maplist(vertex_t v, vertices, ``(by_vertex[v]:nil));
      });

      return ordered_things;
    }
}
